import java.io.File
import java.nio.file.Files

import com.typesafe.sbt.packager.universal.UniversalPlugin.autoImport._
import com.typesafe.sbt.packager.universal.ZipHelper
import ohnosequences.sbt.GithubRelease.keys.{ghreleaseAssets, ghreleaseRepoName, ghreleaseRepoOrg, githubRelease}
import ohnosequences.sbt.SbtGithubReleasePlugin
import sbt.Keys._
import sbt.io.{IO, Path}
import sbt.{AutoPlugin, Def, Plugins, ProjectReference, Setting, Task, taskKey, _}

import scala.language.postfixOps
import scala.sys.process._

object GithubRelease extends AutoPlugin {
  val coverageReportZipKey        = taskKey[File]("Creates a distributable zip file containing the coverage report.")
  val testReportsKey              = taskKey[(File, File)]("Creates test reports in html and zip format.")
  val coursierBootstrapArchiveKey = taskKey[File]("Create zip of all the artifacts generated by coursier bootstrap.")
  val runCoursierBootstrapKey     = taskKey[Unit]("Create all the artifacts required to bootstrap csw using coursier.")
  val runStageWithCoursier        = taskKey[Unit]("Stage with coursier bootstrap script.")

  val aggregateFilter = ScopeFilter(inAggregates(ThisProject), inConfigurations(Compile))

  override def requires: Plugins = SbtGithubReleasePlugin

  override def projectSettings: Seq[Setting[_]] = Seq(
    ghreleaseRepoOrg := "tmtsoftware",
    ghreleaseRepoName := "csw",
    aggregate in githubRelease := false,
    // this creates scoverage report zip file and required for GithubRelease task, it assumes that scoverage-report is already generated
    // and is available inside target folder (if it is not present, empty zip will be created)
    coverageReportZipKey := coverageReportZipTask.value,
    testReportsKey := testReportsTask.value
  )

  private def coverageReportZipTask = Def.task {
    lazy val coverageReportZip = new File(target.value / "ghrelease", "scoverage-report.zip")
    IO.zip(Path.allSubpaths(new File(crossTarget.value, "scoverage-report")), coverageReportZip)
    coverageReportZip
  }

  private def testReportsTask = Def.task {
    val log = sLog.value

    lazy val testReportZip = target.value / "ghrelease" / "test-reports.zip"
    val testReportHtml     = target.value / "ghrelease" / "test-reports.html"
    val xmlFiles           = target.all(aggregateFilter).value.flatMap(targetPath ⇒ Path.allSubpaths(targetPath / "test-reports"))

    // 1. include all xml files in single zip
    IO.zip(xmlFiles, testReportZip)

    // 2. generate html report from xml files
    IO.withTemporaryDirectory { dir ⇒
      // copy xml files from all projects to single directory
      xmlFiles.foreach { case (file, fileName) ⇒ Files.copy(file.toPath, (dir / fileName).toPath) }

      // 2.1 create single xml file by merging all xml's
      val xmlFilesDir     = dir.getAbsolutePath
      val mergedXmlReport = s"$xmlFilesDir/test-report.xml"
      log.info(s"Merging all xml files from dir: $xmlFilesDir using junit-merge command.")
      junitMergeCmd(xmlFilesDir, mergedXmlReport)

      // 2.2 create html test report from merged xml
      val htmlReportPath = testReportHtml.getAbsolutePath
      log.info(s"Generating HTML report at path: $htmlReportPath using junit-viewer command.")
      junitViewerCmd(mergedXmlReport, htmlReportPath)
    }
    (testReportZip, testReportHtml)
  }
  private def junitMergeCmd(inputPath: String, outputPath: String)  = s"junit-merge -d $inputPath -o $outputPath".!
  private def junitViewerCmd(inputPath: String, outputPath: String) = s"junit-viewer --results=$inputPath  --save=$outputPath".!

  private def stageAndZipTask(projects: Seq[ProjectReference]): Def.Initialize[Task[File]] = Def.task {
    val ghrleaseDir = target.value / "ghrelease"
    val log         = sLog.value
    val zipFileName = s"csw-apps-${version.value}"

    lazy val appsZip = new File(ghrleaseDir, s"$zipFileName.zip")

    log.info("Deleting staging directory ...")
    // delete older files from staging directory to avoid getting it included in zip
    // in order to delete directory first and then stage projects, below needs to be a task
    Def.task {
      IO.delete(target.value / "universal" / "stage")
    }.value

    log.info(s"Staging projects: [${projects.mkString(" ,")}]")
    val stagedFiles = projects
      .map(p ⇒ stage in Universal in p)
      .join
      .value
      .flatMap(x ⇒ Path.allSubpaths(x))
      .distinct
      .map {
        case (source, dest) ⇒ (source, s"$zipFileName/$dest")
      }

    ZipHelper.zipNative(stagedFiles, appsZip)
    appsZip
  }

  def coursierArtifacts(projects: Seq[ProjectReference]): Def.Setting[Task[Unit]] = {
    runStageWithCoursier := {
      projects
        .map(p ⇒ publishLocal in p)
        .join
        .value
      val dir = baseDirectory.value / "scripts"
      s"sh $dir/csw-bootstrap.sh ${version.value} ${baseDirectory.value}" !
    }
  }

  private def zipCoursierArtifactsTask(projects: Seq[ProjectReference]): Def.Initialize[Task[File]] = Def.task {
    val ghrleaseDir  = target.value / "ghrelease"
    val zipFileName  = s"csw-bootstrap-apps-${version.value}"
    lazy val appsZip = new File(ghrleaseDir, s"$zipFileName.zip")
    
    coursierArtifacts(projects).init.value

    val tuples = Path.allSubpaths(target.value / "coursier/stage")
    val mapping = tuples
      .map {
        case (source, dest) ⇒ (source, s"$zipFileName/$dest")
      }

    ZipHelper.zipNative(mapping, appsZip)
    appsZip
  }

  def githubReleases(projects: Seq[ProjectReference]): Setting[Task[Seq[sbt.File]]] =
    ghreleaseAssets := {
      val (testReportZip, testReportHtml) = testReportsKey.value
      Seq(
        stageAndZipTask(projects).value,
        coverageReportZipKey.value,
        zipCoursierArtifactsTask(projects).value,
        testReportZip,
        testReportHtml
      )
    }
}
